<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
    <link rel="stylesheet" href="css/bootstrap.min.css"/>
    <link rel="stylesheet" href="css/font-awesome.min.css"/>
    <link rel="stylesheet" href="css/main.css"/>

    <title>Abschussarbeit Informatik</title>
</head>
<body>
<!--  Start Upper Bar -->
<div class="upper-bar">
    <div class="container">
        <div class="row">
            <div class="col-sm">
                <i class="fa fa-envelope"></i> <span>yassine.chakri@smail.inf.h-brs.de</span>
            </div>
            <div class="col-sm text-right bs">
                Bachelorarbeit im Studiengang Informatik
            </div>
            <div class="col-sm">
                <span class="get-quote"><a class="hbsNavbar" target="_blank" href="https://www.h-brs.de/de"> Hochschule Bonn-Rhein-Sieg  </a></span>
            </div>
        </div>
    </div>
</div>

<!-- End Upper Bar -->
<!-- Start Nav bar  -->
<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container">
        <a class="navbar-brand" href="/">
            <span>Graph </span><span>Coloring</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-nav"
                aria-controls="navbarSupportedContent"
                aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="main-nav">
            <ul class="navbar-nav ml-auto" id="myDIV">
                <li class="nav-item">
                    <a class="nav-link einfuer" href="#">Einf√ºhrung </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link anwendun" href="#">Anwendungen</a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown" aria-haspopup="true"
                       aria-expanded="false">
                        Algorithmen <span class="sr-only">(current)</span>
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item exakte" href="#">Exakte Algorithmen</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item heuristische" href="#">Heuristike Algorithmen</a>
                    </div>
                </li>
                <!--<li class="nav-item">-->
                    <!--<a class="nav-link observat" href="#">Observation</a>-->
                <!--</li>-->
                <li class="nav-item">
                    <a class="nav-link" href="/implementierung">Implementierung</a>
                </li>

            </ul>
        </div>
    </div>
</nav>
<!-- End Nav Bar  -->

<!--  Start Slider -->
<div class="slider">
    <div id="main-slider" class="carousel slide" data-ride="carousel">
        <div class="carousel-inner">
            <h2>Bachelorarbeit <br/> <span>Implementierung und Evaluation von <span id="firstt">
            F√§rbungsalgorithmen</span></span>
            </h2>
            <div class="overlay"></div>
            <div class="carousel-item carousel-one active">
            </div>
            <div class="carousel-item carousel-two">
            </div>
            <div class="carousel-item carousel-three">
            </div>
            <div class="carousel-item carousel-four">
            </div>
        </div>
        <ol class="carousel-indicators">
            <li data-target="#main-slider" data-slide-to="0" class="active"></li>
            <li data-target="#main-slider" data-slide-to="1"></li>
            <li data-target="#main-slider" data-slide-to="2"></li>
            <li data-target="#main-slider" data-slide-to="3"></li>
        </ol>

    </div>
</div>
<!--  End Slider  -->
<!--  Start Einfuerung  -->
<div class="startBody">
    <div class="einfuerung">
        <div class="container">
            <div class="myHeading this">
                <h1>Graph Coloring</h1>
                <h2 class="einf">Einf√ºhrung</h2>
                <p  align="justify">Einen Graph kann man sich in der Mathematik als eine Menge von Objekten vorstellen, bei denen einige Objektpaare durch Verkn√ºpfungen verbunden sind. Die miteinander verbundenen Objekte werden √ºblicherweise Knoten genannt, wobei die Verkn√ºpfungen Knotenpaare verbinden, die als Kanten bezeichnet werden. Mithilfe von Graphen k√∂nnen √ºberraschend viele Problembereiche modelliert werden, darunter soziale Netzwerke, Chemie, Terminplanung, Paketzustellung, Satellitennavigation, Elektrotechnik und Computervernetzung. Das F√§rbungsproblem ist eines der bekanntesten Probleme auf dem Gebiet der Graphentheorie. Es besitzt eine lange und ber√ºhmte Geschichte. In aller K√ºrze fragt es bei einem gegebenen Graph, wie vorgegangen werden k√∂nnte. So m√ºssen Zuweisungen von "Farben" zu allen Knoten erfolgen, sodass (a) keine durch eine Kante verbundenen Knoten die gleiche Farbe erhalten und (b) die Anzahl der verschiedenen verwendeten Farben minimiert werden.</p>
                <img src="images/GraphCol.png" alt="Graph Coloring"/>
                <p  align="justify">Die Abbildung zeigt einen Graphen mit zehn Eckpunkten (die Kreise) und 21 Kanten (die Linien, die die Kreise verbinden). Es zeigt auch ein Beispiel f√ºr die F√§rbung dieses Graphs, der f√ºnf verschiedene Farben verwendet. Diese L√∂sung kann als "richtige" F√§rbung bezeichnet werden, da alle durch Kanten verbundenen Knotenpaare je nach Problem unterschiedlichen Farben zugewiesen wurden. Insbesondere wurden zwei Knoten der Farbe 1, drei Knoten der Farbe 2, zwei Knoten der Farbe 3, zwei Knoten der Farbe 4 und ein Knoten der Farbe 5 zugewiesen</p>
                <img src="images/GraphCol2.png" alt="Graph Coloring 2"/>
                <p  align="justify">Tats√§chlich ist diese L√∂sung nicht die einzig m√∂gliche 5-Farben-Darstellung f√ºr diesen Beispielgraph. Wenn die Farben der beiden unteren Knoten in der Abbildung beispielsweise vertauscht werden, wird eine andere richtige 5-Farben-Darstellung erhalten. Es ist auch m√∂glich, den Graph mit sechs bis zehn Farben einzuf√§rben (wobei zehn die Anzahl der Knoten im Graph ist), da das Zuweisen eines Knotens zu einer zus√§tzlichen, neu erstellten Farbe weiterhin sicherstellt, dass die F√§rbung korrekt bleibt. Aber was ist, wenn dieser Graph mit weniger als f√ºnf Farben eingef√§rbt wird?
                    Ist das m√∂glich?
                </p>
                <p align="justify">Zur Beantwortung dieser Frage wird in der zweiten Abbildung in Betracht gezogen, in der die gepunktete Linie einen ausgew√§hlten Teil des Graphen angibt. Wenn alles von au√üerhalb dieser Auswahl entfernt wird, bleibt ein Sub Graph mit nur f√ºnf Knoten √ºbrig. Wichtig ist, dass jedes Paar von Knoten in diesem Untergraphen eine Kante zwischen sich hat. Wenn nur vier Farben zur Verf√ºgung stehen w√ºrden, wie in der Abbildung gezeigt, k√∂nnte dieser Teilgraph nicht richtig gef√§rbt werden, da seine f√ºnf Knoten in diesem Fall alle einer anderen Farbe zugewiesen werden m√ºssen. Dies l√§sst den Schluss zu, dass die L√∂sung in Abbildung 1 tats√§chlich optimal ist, da keine L√∂sung verf√ºgbar ist, die weniger als f√ºnf Farben verwendet.</p>
                <p></p>
                <p></p>

            </div>
        </div>
    </div>
    <!--  End Einfuerung  -->
    <!-- Start Anwendung  -->
    <div class="anwendung">
        <div class="container">
            <div class="myHeading this">
                <h2 class="anwend">Anwendungen</h2>
                <h3>Scheduling</h3>
                <p align="justify">Vertex-Modelle f√ºr eine Reihe von Planungsproblemen. In der saubersten Form muss ein bestimmter Satz von Jobs Zeitfenstern zugewiesen werden, jeder Job erfordert einen solchen Slot. Jobs k√∂nnen in beliebiger Reihenfolge eingeplant werden. Jobpaare k√∂nnen jedoch in einem Konflikt miteinander stehen, dass sie m√∂glicherweise nicht demselben Zeitfenster zugewiesen werden, z. B. weil beide auf einer gemeinsam genutzten Ressource basieren. Der entsprechende Graph enth√§lt einen Knoten f√ºr jeden Job und eine Kante f√ºr jedes in Konflikt stehende Jobpaar. Die Farbzahl des Graphen ist genau die minimale Zeitspanne, die optimale Zeit, um alle Jobs ohne Konflikte zu beenden.</p>
                <p align="justify">Details zum Planungsproblem definieren die Struktur des Graphen. Beim Zuweisen von Flugzeugen zu Fl√ºgen ist der resultierende Konfliktgraph beispielsweise ein Intervallgraph, sodass das Farbproblem effizient gel√∂st werden kann. Bei der Bandbreitenzuweisung f√ºr Radiosender ist der resultierende Konfliktgraph ein Einheitsdiskgraph, sodass das Farbproblem 3-approximierbar ist.</p>

                <h3>Registerzuteilung</h3>
                <p align="justify">Ein Compiler ist ein Computerprogramm, das eine Computersprache in eine andere √ºbersetzt. Um die
                    Ausf√ºhrungszeit des resultierenden
                    Codes zu verbessern, ist eine der Techniken der Compiler-Optimierung die Registerzuweisung, bei der
                    die am h√§ufigsten verwendeten Werte
                    des kompilierten Programms in den schnellen Prozessorregistern gespeichert werden. Idealerweise
                    werden Werte Registern zugewiesen,
                    sodass sie bei ihrer Verwendung alle in den Registern gespeichert werden k√∂nnen.</p>
                <p align="justify">Der Lehrbuchansatz f√ºr dieses Problem besteht darin, es als ein F√§rbungsproblem zu
                    modellieren. Der Compiler erstellt
                    einen Interferenzgraph, wobei Vertices Variablen sind und eine Kante zwei Vertices verbindet, wenn
                    sie gleichzeitig ben√∂tigt werden.
                    Wenn der Graph mit k Farben gef√§rbt werden kann, kann jeder Satz von Variablen, der gleichzeitig
                    ben√∂tigt wird, in h√∂chstens
                    k Registern gespeichert werden.</p>
                <h3>Sudoku-Puzzle</h3>
                <p align="justify">Das Sudoku-Puzzle ist zu einem sehr beliebten Puzzle geworden. Das R√§tsel besteht aus einem 9√ó9-Gitter, in dem einige der Eintr√§ge des Gitters eine Zahl von 1 bis 9 haben. Das Ausf√ºllen der Tabelle mit den Zahlen muss diesen Regeln folgen: Zahlen in Zeilen werden nicht wiederholt. Zahlen in Spalten werden nicht wiederholt. Zahlen in 3√ó3 Bl√∂cken werden nicht wiederholt. Die Reihenfolge der Zahlen beim Ausf√ºllen ist nicht wichtig.
                </p>
                <p align="justify">Der Graph hat 81 Knoten, wobei jeder Knoten einer Zelle im Gitter entspricht. Zwei verschiedene Knoten werden benachbart sein, wenn und nur dann, wenn sich die entsprechenden Zellen im Gitter entweder in der gleichen Zeile oder in der gleichen Spalte oder im gleichen Unterraster befinden. Jedes abgeschlossene Sudoku-Feld entspricht dann einer k-F√§rbung des Graphen. Es wird ein n2 √ón2 Gitter betrachtet. Jeder Zelle im Gitter wird ein Knoten mit der Bezeichnung (i, j)
                <br /> 1 ‚â§ i, j ‚â§ n2 zugeordnet. Zwei Ecken (i, j) und (i‚Ä≤, j‚Ä≤) liegen nebeneinander, wenn [i= i‚Ä≤] oder [j = j‚Ä≤] oder [i/n]= [i‚Ä≤/n] und [j/n]= [j‚Ä≤/n].
                </p>
                <img src="images/sudokuBs.png" alt="sudoku" />
            </div>
        </div>
    </div>
    <!-- End Anwendung  -->
    <!--  Start Algorithmen  -->
    <div class="algorithmen">
        <div class="container">
            <div class="myHeading">
                <h2>Algorithmen</h2>

                <h3 class="exakt">Exakte Algorithmen</h3>
                <p align="justify">Exakte Algorithmen bestimmen immer die optimale L√∂sung f√ºr ein Rechenproblem, vorausgesetzt, sie haben zu viel Zeit. Eine M√∂glichkeit, NP-vollst√§ndige Probleme, wie das F√§rbungsproblem exakt zu l√∂sen, besteht darin, den L√∂sungsraum gr√ºndlich zu durchsuchen.</p>

                <h4>Backtracking Algorithmus</h4>
                <p align="justify">Bei Backtracking handelt es sich um eine allgemeine Methode, mit der eine optimale L√∂sung (oder m√∂glicherweise alle optimalen L√∂sungen) f√ºr ein Berechnungsproblem wie das F√§rbungsproblem ermittelt werden kann. Backtracking-Algorithmen bauen systematisch Teill√∂sungen zu Komplettl√∂sungen auf. Sobald jedoch w√§hrend dieses Konstruktionsprozesses Beweise daf√ºr vorliegen, dass es keine M√∂glichkeit gibt, die aktuelle Teill√∂sung zu vervollst√§ndigen, um eine optimale L√∂sung zu erhalten, wird der Algorithmus zur√ºckverfolgt, um geeignete M√∂glichkeiten zum Anpassen der aktuellen Teill√∂sung zu finden. </p>
                <img src="images/Backtrack1.png" width="650" height="500" />

                <h4>Lineare Programmierung Algorithmus</h4>
                <p align="justify">Die erste Nebenbedingung besagt, dass jede Ecke genau eine Farbe zugeordnet bekommt.
                    Die n√§chste Bedingung verkn√ºpft die beiden Arten von Variablen, eine Ecke
                    kann nur dann mit Farbe k gef√§rbt werden, falls Yk = 1 gilt. Die dritte Bedingung
                    stellt sicher, dass benachbarte Ecken verschiedene Farben bekommen. Zum Schluss
                    wird sichergestellt, dass die Variablen nur die Werte 0 und 1 annehmen k√∂nnen.</p>
                <img src="images/LP1.png" width="550" height="250" />

                <h3 class="heuristi">Heuristike Algorithmen</h3>
                <p align="justify">Eine heuristische Technik ist ein Ansatz zur Probleml√∂sung oder Selbstfindung, bei dem eine praktische Methode angewendet wird, die nicht garantiert, optimal und perfekt zu sein, sondern ausreicht, um ein unmittelbares Ziel zu erreichen. Ist es unm√∂glich oder unpraktisch, eine optimale L√∂sung zu finden, so k√∂nnen heuristische Methoden eingesetzt werden, um die Suche nach einer zufriedenstellenden L√∂sung zu beschleunigen.</p>

                <h4>Greedy Algorithmus</h4>
                <p align="justify">Der GREEDY-Algorithmus ist einer der einfachsten, aber grundlegendsten heuristischen Algorithmen f√ºr das F√§rbungsproblem. Der Algorithmus nimmt die Knoten nacheinander in einer (m√∂glicherweise willk√ºrlichen) Reihenfolge und weist jedem Knoten seine erste verf√ºgbare Farbe zu. Da es sich um einen heuristischen Algorithmus handelt, sind die von ihm erzeugten L√∂sungen m√∂glicherweise nicht optimal.</p>
                <img src="images/Greedy.png" width="550" height="300" />

                <h4>Largest First Algorithmus</h4>
                <p align="justify">Der Largest First (LF) Algorithmus ist einer der √§ltesten und einfachsten Algorithmen zum sequentiellen F√§rbungsproblem. Die Methode basiert auf der Beobachtung, dass Knoten mit geringem Grad eine flexiblere Farbwahl erm√∂glichen. Infolgedessen m√ºssen die Knoten mit hohem Grad zuerst eingef√§rbt werden. Die LF-Methode kann so implementiert werden, dass sie in O (m + n) Zeit l√§uft.</p>
                <img src="images/LF.png" width="550" />

                <h4>DSATUR Algorithmus</h4>
                <p align="justify">Der DSATUR-Algorithmus (abgek√ºrzt als "degree of saturation") wurde urspr√ºnglich von Br√©laz (1979) vorgeschlagen. Im Wesentlichen ist es dem GREEDY-Algorithmus sehr √§hnlich, da es jeden Knoten nach einer bestimmten Reihenfolge abwechselt und ihn dann der ersten geeigneten Farbklasse zuordnet, wobei bei Bedarf neue Farbklassen erstellt werden. Der Unterschied zwischen den beiden Algorithmen liegt in der Art und Weise, wie diese Knotenreihenfolgen erzeugt werden. Bei GREEDY wird die Bestellung vor dem F√§rben festgelegt. Andererseits wird f√ºr den DSATUR-Algorithmus die Wahl, welcher Knoten als N√§chstes gef√§rbt werden soll, heuristisch auf der Grundlage der Eigenschaften der aktuellen Teilf√§rbung des Graphen entschieden. Diese Auswahl basiert haupts√§chlich auf dem S√§ttigungsgrad der Eckpunkte, der wie folgt definiert ist:</p>
                <img src="images/dSatur.png" width="550" />

                <h4>Recursive Largest First Algorithmus</h4>
                <p align="justify">Der RLF-Algorithmus wurde urspr√ºnglich von Leighton (1979) entwickelt, teilweise zur Erstellung von L√∂sungen f√ºr gro√üe Zeitplanprobleme. Das Verfahren funktioniert, indem es einen Graphen mit einer Farbe nach dem anderen einf√§rbt, und nicht einem Knoten nach dem anderen. In jedem Schritt identifiziert der Algorithmus mithilfe von Heuristiken eine unabh√§ngige Gruppe von Knoten im Graphen, die dann derselben Farbe zugeordnet werden. Diese unabh√§ngige Menge wird folglich aus dem Graphen entfernt. Der Vorgang wird auf dem resultierenden kleineren Teilgraphen wiederholt. Dieser Vorgang wird fortgesetzt, bis der Untergraph leer ist. An diesem Punkt sind alle Knoten eingef√§rbt. Es existiert somit eine praktikable L√∂sung. Leighton (1979) hat bewiesen, dass RLF im schlimmsten Fall O (n^3) ist, was einen h√∂heren Rechenaufwand verursacht als die Algorithmen O (n^2) GREEDY und DSATUR. Dieser Algorithmus ist jedoch nat√ºrlich immer noch polynomial begrenzt.</p>
                <img src="images/RLF.png" width="650"/>

                <h4>Welsh Powell Algorithmus</h4>
                <p align="justify">Der WP Algorithmus ist ein effizienter Algorithmus zur Einf√§rbung von Graph G. Dieser Algorithmus gibt uns nur die obere Schranke der chromatischen Zahl von G. Daher wird nicht immer die Anzahl der Mindestfarben angegeben, die beim F√§rben von Graphen ben√∂tigt werden. F√ºr den gegebenen Graph G wird die Menge der Knoten als V = {V_1, V_2, ......, V_n} und die Menge der Farben der Knoten als ùëπ = {c_1, c_2, ‚Ä¶, c_k} beschrieben.</p>
                <img src="images/WP.png" width="550" />

                <h4>Depth-first search</h4>
                <p align="justify">Der DFS-Algorithmus geht von einem Knoten v aus. Nachdem er den Knoten gef√§rbt hat, durchl√§uft er ihn und f√§rbt dessen benachbarten Knoten (z.B. x), der vorher nicht besucht wurde. Er markiert ihn als ‚Äûbesucht‚Äú und ‚Äûgef√§rbt‚Äú und f√§hrt mit dem benachbarten Knoten von x fort. Wenn der DFS-Algorithmus an einem Knoten darauf st√∂√üt, dass alle benachbarten Knoten besucht werden, zieht er sich zur√ºck, bis er den ersten Knoten mit einem benachbarten Knoten findet, der noch nie zuvor durchlaufen wurde. Anschlie√üend f√§rbt er diesen Knoten. Durchquert er ihn, so f√§hrt er mit dessen benachbarten Knoten fort, bis er alle Knoten f√§rbt und wieder zur√ºckkehren muss. Auf diese Weise durchquert er alle Knoten, die ab dem anf√§nglichen Knoten v erreichbar sind. Das Konzept besteht darin, alle Nachbarknoten eines Nachbarknoten zu besuchen und zu f√§rben, bevor die anderen Nachbarknoten besucht werden.</p>
                <img src="images/DFS.png" width="550" />

                <h4>Breadth-first search</h4>
                <p align="justify">Die Breitensuche (BFS) beginnt auf der Start-Ebene 0 Knoten X des Graphen G. Anschlie√üend werden alle Knoten besucht und gef√§rbt, die die Nachbarn von X sind. Nach dem Besuch werden die Knoten als ‚Äûbesucht‚Äú und ‚Äûgef√§rbt‚Äú markiert und in Level-1 platziert. Dann werden mit den Level-1-Knoten begangen und die gleiche Methode auf jeden Level-1-Vertex und so weiter angewandt. Die BFS-Traversal endet, wenn jeder Knoten des Graphen besucht und gef√§rbt wurde.</p>
                <img src="images/BFS.png" width="550"/>
            </div>
        </div>
    </div>

    <!--<div class="observation">-->
        <!--<div class="container">-->
            <!--<div class="observ">-->

            <!--</div>-->
        <!--</div>-->
    <!--</div>-->

    <footer class="bd-footer text-muted">
        <div class="container">
            <ul class="bd-footer-links">
                <li><a href="https://github.com/ychakr2s/WebAbschlussRepository">GitHub</a></li>
                <li><a href="#">About</a></li>
            </ul>
            <p>Entworfen und gebaut mit all der Liebe der Welt von @Yassine Chakri.</p>
        </div>
    </footer>
</div>

<script src="js/jquery-3.4.0.min.js"></script>
<script src="js/popper.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/main.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@8"></script>
<script language="javascript" type="text/javascript">
    //<![CDATA[
    var matrix = [];
    $(document).ready(function () {

        $("#grid").fadeIn(900);
        var header = document.getElementById("myDIV");
        var btns = header.getElementsByClassName("nav-item");
        for (var i = 0; i < btns.length; i++) {
            btns[i].addEventListener("click", function () {
                var current = document.getElementsByClassName("active");
                current[0].className = current[0].className.replace(" active", "");
                this.className += " active";
            });
        }

        console.log("Salam i am from Ready jQuery: ", matrix);
    });

    //]]>

</script>
<!--noch weiter-->
</body>
</html>
